/*
 * Copyright (C) 1997, Doug Simon
 *
 * See the file "LICENSE.TERMS" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 */

//File: TypeDefs.cpp
//Author: Doug Simon
//Purpose: to implement the conversion operations between the two enumerated type declared in the .h file.
//		Some of the routines defined have been automatically generated by a script (in the GEN subdirectory) to
//		Ensure consistency among the operations that deal with the full instruction set

#include <ctype.h>
#include <assert.h>
#include <iostream.h>
#include <string.h>
#include <stdlib.h>
#include "TypeDefs.h"

#define MAX_OPCODE_LEN 7	// the max. length of an opcode

// ### BEGIN GENERATED CODE ###

// A comparsion function for pointers to strings
int comp_fn(const void* first, const void* second) { return strcmp(*(char**)first,*(char**)second);  }

// The array of opcode strings indexed by their corresponding opcode type
const char* _opcodeStrings[] = {
	"add", "addcc", "addx", "addxcc", "and", "andcc", "andn",
	"andncc", "b", "b,a", "ba", "ba,a", "bcc", "bcc,a", "bclr",
	"bcs", "bcs,a", "be", "be,a", "bg", "bg,a", "bge", "bge,a",
	"bgeu", "bgeu,a", "bgu", "bgu,a", "bl", "bl,a", "ble", "ble,a",
	"bleu", "bleu,a", "blu", "blu,a", "bn", "bn,a", "bne", "bne,a",
	"bneg", "bneg,a", "bpos", "bpos,a", "bset", "btog", "btst", "bvc",
	"bvc,a", "bvs", "bvs,a", "call", "cb0", "cb0,a", "cb01", "cb01,a",
	"cb012", "cb012,a", "cb013", "cb013,a", "cb02", "cb02,a", "cb023",
	"cb023,a", "cb03", "cb03,a", "cb1", "cb1,a", "cb12", "cb12,a",
	"cb123", "cb123,a", "cb13", "cb13,a", "cb2", "cb2,a", "cb23",
	"cb23,a", "cb3", "cb3,a", "cba", "cba,a", "cbn", "cbn,a", "clr",
	"clrb", "clrh", "cmp", "cpop1", "cpop2", "dec", "deccc", "fabss",
	"faddd", "faddq", "fadds", "fba", "fba,a", "fbe", "fbe,a", "fbg",
	"fbg,a", "fbge", "fbge,a", "fbl", "fbl,a", "fble", "fble,a",
	"fblg", "fblg,a", "fbn", "fbn,a", "fbne", "fbne,a", "fbo",
	"fbo,a", "fbu", "fbu,a", "fbue", "fbue,a", "fbug", "fbug,a",
	"fbuge", "fbuge,a", "fbul", "fbul,a", "fbule", "fbule,a", "fcmpd",
	"fcmped", "fcmpeq", "fcmpes", "fcmpq", "fcmps", "fdivd", "fdivq",
	"fdivs", "fdmulq", "fdtoi", "fdtoq", "fdtos", "fitod", "fitoq",
	"fitos", "flush", "fmovs", "fmuld", "fmulq", "fmuls", "fnegs",
	"fpop1", "fpop2", "fqtod", "fqtoi", "fqtos", "fsmuld", "fsqrtd",
	"fsqrtq", "fsqrts", "fstod", "fstoi", "fstoq", "fsubd", "fsubq",
	"fsubs", "inc", "inccc", "jmp", "jmpl", "ld", "ldc", "ldcsr",
	"ldd", "lddc", "lddf", "ldf", "ldfsr", "ldsb", "ldsh", "ldstub",
	"ldub", "lduh", "mov", "mulscc", "neg", "nop", "not", "or",
	"orcc", "orn", "orncc", "rd", "restore", "ret", "retl", "save",
	"sdiv", "sdivcc", "set", "sethi", "sll", "smul", "smulcc",
	"sra", "srl", "st", "stb", "stbar", "stc", "stcsr", "std",
	"stdc", "stdcq", "stdf", "stf", "stfsr", "sth", "sub", "subcc",
	"subx", "subxcc", "swap", "taddcc", "taddcctv", "tst", "tsubcc",
	"tsubcctv", "udiv", "udivcc", "umul", "umulcc", "unimp", "wr",
	"xnor", "xnorcc", "xor", "xorcc", "invalid"
};

char const* Type2String(iType t) { return _opcodeStrings[t]; }

iType String2Type(const char* opString)
{
	const int NumOpcodes = 236 + 1;
	char** result = static_cast<char**>(bsearch(&opString,_opcodeStrings,NumOpcodes,sizeof(_opcodeStrings[0]),comp_fn));
	assert(result);
	//return static_cast<iType>((static_cast<int>(result) - static_cast<int>(_opcodeStrings)) / sizeof(char**));
	return (iType)(((int)(result) - (int)(_opcodeStrings)) / sizeof(char**));

}

// ### END GENERATED CODE ###

char *Type2String(bbType t)
{
	switch (t) {
	case nway:
		return "nway";
	case cBranch:
	        return "cBranch";
        case uBranch:
                return "uBranch";
        case call:
                return "call";
        case ret:
                return "ret";
        case fall:
                return "fall";
        default:
                return "other";
        }
}

bbType iType2bbType(iType t)
{
//A subset of the control flow transfer instructions are detected as simple
//fall through instructions due to the fact that they never actually result
//in a transfer of control. The membership of this subset is:
//	iBn,iBn_a,iFbn,iFbn_a,iCbn,iCbn_a

	switch (t) {
	case iJmp:
		return nway;

	case iB: case iB_a: case iBa: case iBa_a: case iFba: case iFba_a:
	case iCba: case iCba_a:
		return uBranch;

	case iCall:
		return call;

	case iBne: case iBe: case iBg: case iBle: case iBge: case iBl:
	case iBlu: case iBgu: case iBleu: case iBgeu: case iBcc: case
	iBcs: case iBpos: case iBneg: case iBvc: case iBvs: case iBne_a:
	case iBe_a: case iBg_a: case iBle_a: case iBge_a: case iBl_a:
	case iBlu_a: case iBgu_a: case iBleu_a: case iBcc_a: case iBcs_a:
	case iBpos_a: case iBneg_a: case iBgeu_a: case iBvc_a: case
	iBvs_a: case iFbu: case iFbg: case iFbug: case iFbl: case iFbul:
	case iFblg: case iFbne: case iFbe: case iFbue: case iFbge: case
	iFbuge: case iFble: case iFbule: case iFbo: case iFbu_a: case
	iFbg_a: case iFbug_a: case iFbl_a: case iFbul_a: case iFblg_a:
	case iFbne_a: case iFbe_a: case iFbue_a: case iFbge_a: case
	iFbuge_a: case iFble_a: case iFbule_a: case iFbo_a: case iCb3:
	case iCb2: case iCb23: case iCb1: case iCb13: case iCb12: case
	iCb123: case iCb0: case iCb03: case iCb02: case iCb023: case
	iCb01: case iCb013: case iCb012: case iCb3_a: case iCb2_a: case
	iCb23_a: case iCb1_a: case iCb13_a: case iCb12_a: case iCb123_a:
	case iCb0_a: case iCb03_a: case iCb02_a: case iCb023_a: case
	iCb01_a: case iCb013_a: case iCb012_a:
		return cBranch;

	case iRet: case iRetl:
		return ret;

	default:
		return fall;
	}
}

