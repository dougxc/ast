CS486 Project diary
Doug Simon, 1997

To iterate is human, to recurse, divine.


26/5: Finished developmenmt of the instructions(.h & .cpp), source(.h & .cpp)
and string.h. Includes limited testing.
27/5: Begin development of bldGraph module. Issues encountered so far:
        - how to deal with indirect register jumps. Apparently, some
        can be solved
          with out too much problem. Will try and include functionality
          for these subclass of programs.
        - what to do with Ticc instructions as far as control flow is
        concerned.  - some 'b,a' instructions are seperated from their
        delayed instructions by
          a label. Does this mean that the delayed instructions are
          removed from the basic block (c.f. ba,a instruction)?

11/6: New assumptions -
                i) only testing on assembly generated by 'gcc -S -O3'
                ii) the class of assembly files tested is then restrained to:
                 a)  those with no indirect jumps
                 b)  those with indirect jumps that use an easily detected PLT
                 c)  those with no priveleged instructions (applications
                 programs don't
                     use them). This excludes rett, rdasr,rdpsr,rdtbr
                     rdwim,wrasr,wrpsr,wrtbr,wrwim etc (and alternate space
                     instructions).
                 d)  Ticc instructions because they will complicate the
                 control flow
                     graph generation but are do generally appear in
                     applications programs
                     (and don't appear in any of the test sources). Ommitting
                     them doesn't
                     impact upon the validity of the timing test
                     results. However, it
                     does mean that every control transfer instruction (CTI)
                     is also
                     a delayed CTI (DCTI).

        Figured out the semantics for the non-documented gcc-produced
        assembly mnemomics:
                GNU syntax  | Sparc Instruction
                -------------------------------
                b           | ba
                b,a         | ba,a
                blu         | bcs
                blu,a       | bcs,a
                bgeu        | bcc
                bgeu,a      | bcc,a

        Strategty for determining the dest. labels for a 'jmp' instruction. All
        jmp we will
        consider have the following pattern:

                jmp %o0
                .align 4
        .LL[0-9]+                       //that is, a label with only numeric
        chars after LL
                .word LABEL <repeated zero or more lines with possibly
                different labels>
        .LL[0-9]+

        Scan for this pattern and put all the labels following a '.word'
        after the jmp
        instruction. All the 'jmp's in the programs used for testing will
        fit this
        pattern. This must be done before the other preprocessing. The
        first label
        is also removed (i.e. the one after the '.align 4' instruction).

        Updated the preprocessor to do the above task. The result is that
        the dest's for
        a 'jmp' instruction replace the original operand. Duplicate dest's
        are also
        removed.

        Had to remove two programs from the test set that had 'jmp'
        instructions that didn't
        conform to the above pattern.

13/6:	What to do with b,a and ba,a instructions. Since they both annul
their next instruction,
	one possible strategy would be to remove that instruction
	altogether. However, analysis
	of the test programs has show that gcc will always generate code
	that has a label immediately
	succeeding one of these instructions. So, the stratgey I will adopt
	will be to insert a nop
	in the delay slot. This preserves the semantics of the delayed nature
	of these two instructions
	as well as preserving the fact that the original DI is not flow
	control dependent  on it's
	predecessor. A decision will be made later as to whether or not to
	remove these extra nops
	from the final output.

	We can now treat all CTI's uniformally. All delayed instructions
	will simply be placed in the
	same block as their preceeding CTI. This enables us to output the
	reachable code in exactly
	the same form as it was input (appart from the sematic-preserving
	insertion of extra nop's mentioned
	above) . Avoiding moving the DI's into other blocks does not break
	the original structure of flow
	control.

	- first out edge for a conditional jump is the fall through edge

14/6:	Analysed test programs and found that gcc never generates a routine
	label (eg main:) and a jump label (eg .LL30) at the same address. I
	have therefore made the assumption that this will never occur and
	it is hardcoded into the source.

	Completed graph building module. Included a temp function to output
	a graphviz file.

15/6:	Generated more test programs from the same source but without and
optimaization turned on. Did
	this to test the functionality of the remove unreachable blocks
	code. As expected, they are few
	(only found one) unreachable blocks in the optimised programs.

25/6:
	determine back edges by looking at the dfs last number of the nodes:
		(edge(p,q) & p.dfsLast < q.dfsLast) => backEdges(edge(p,q))

29/6:	not much further progress on the actual implememntation. Spent most
of my time
	figuring out the behviour of C++. It seems as though the initial
	value of pointers
	cannot be assumed to be within any discernible range of values. This
	makes it a
	bit tricky when trying to give a defalut value to a pointer parameter
	for a function.

3/7:	Pretty much redesigned the code to be almost completely object
oriented. Also, learnt
	a neat way to get around type checking errors when using the `qsort'
	and `bsearch'
	functions in <stdlib.h>:

		typedef int (*pFunc)(const void*, const void*);

	Now, just cast the compare function passed to both qsort and bsearch
	to (pFunc). Simple!

4/7:	Above fix doesn't quite seem to work when used within a class. Doh!!

14/7:	Gave mid year seminar. Feedback indicates more work needed of the
following points:
	- more eye contact
	- less time spent on outline
	- don't try and work through exercises in a short talk, just have
	the answers ready
	- need a better demo graph incorporating a while loop, repeat loop,
	nested loop, one
	  conditional. Also, have additional info displayed as well
	  eg. immed. dom. list,
	  rev. ordering list and interval for each node.

18/7:	Had to alter conditional structuring algorithm so that the correct
follow was found.
		Having found a suitable follow for a given conditional,
		only SOME of the nodes in the
		unresolved list are then tagged as having the same follow
		and subsequently removed.
		That is only the nodes that have a greater dfs last value
		than the follow as these

19/7: Every procedure only seems to have one ret statement. Additionally, most
	of these statements are in their own basic block along with their
	delayed
	instruction. So, any other blocks that have an unconditional branch
	to one
	of these type of ret blocks is really just doing a return. Is it a Good
	Idea (tm) to simply remove any edges of this type as they will
	otherwise
	cause a possibly other wise structured graph to look unstructured? If
	so
	then we should also change the type of this node to be 'ret' instead of
	'uBranch'.

28/7: Changed the algorithm for determining the type of a loop. The main
difference is that a loop with a two way latching
	node cannot be a while node. An implication of this is that a two
	way loop header with a one way latch node will be
	structured as a while header. This means that the following graph
	will produce the listed code:

         |             while (A) {
         V               B;
   ----->A         L1:   D;
  |     / \            }
  |    B   C           C;
  |     \ /            goto L1;
   ------D

   It is as yet undecided whether or this is preferable to the alternative:

   loop {
      if (A)
         B;
      else
         C;
      D;
   }

	The latter case could be considered more favourable due to the fact
	that it doesn't generate any goto's in the
	final code.

29/7:	Deveopled algorithm for doing the time stamping of the nodes that will
		be used to reason about certain properties of a conditional
		structure:

		//pre: for each node in the graph, InEdgesVisited = 0,
		NumForwardInEdges has been
		//		determined.
		//post: each node has the relevant time stamp tuple

		time = 1

		CondStamp(u)
			u.InEdgesVisited++
			if (u.traversed) then
				if (u.InEdgesVisited == u.NumNonBackInEdges)
				then
					u.lastStamp = time++
				end if
			else
				u.firstStamp = time++
				u.traversed = true
				for (v in NonBackOutEdges(u)
					CondStamp(v)
				end for
				if (u.InEdgesVisited == u.NumNonBackInEdges)
				then
					u.firstStamp = time++
				end if
			end if
		end CondStamp

	Using the above time stampings, an already structured conditional
	can be checked for
	being properly structured with the following algorithm:

\begin{axdef}
StructuredCond: Node \fun Node \fun \bool \\
\ST
StructuredCond = \lambda head : Node @ \lambda latch : Node @ \\
\t2	\{\forall n : Nodes \bbar head.order > n.order > latch.order @ \\
\t4	    IsIn(n.interval,head.interval) \land \\
\t4	    (IsIn(n.interval, latch.interval) \lor
Overlaps(n.interval,latch.int
\end{axdef}

31/7:	Follow of an endless loop. Consider all the successor's of conditionals
within the loop
		that have a follow outside of the loop. For each of these
		conditionals, consider only
		the successor that isn't in the loop. The other successor
		should always be in the loop.
		Of the remaining successors under consideration, choose the
		follow to be the one with
		the greatest dfsLast value.

		The above should work given that one of the successors of
		a conditional in the loop
		with a follows outside the loop, will always be in the loop.

		Found a case where a two node has both edges go to the same
		node. Must be some strange behaviour
		in the compiler. Have to add a new conditional type for this
		type of node 'If' (no then, no else).

		****NEWS FALSH****
		The second set of time stampings may not be required at
		all. At present, they are only being used
		to determine whether or not a conditional is structured. This
		in turn is being used to determine
		the type of a loop where there is a choice between PreTested
		and Endless. We say the loop is a
		PreTested if its header is the head of an unstructured
		conditional. However, this is no good in the
		case where an endless loop begins with an structured
		conditional but the follow of this conditional
		is still within the loop: eg

      ------->A           do {
     /       / \            if (A)
     |      B   |              if(B)
     |      |\ /                  C;
     |      | X             else
     |      |/ \               goto L1;
     |      C   |           E;
     |       \  |         }
     |        \ |
     |         \|
     |          D
     |          |
      \_________E


		While, reading over the code produced so far, I am wondering
		why we need to tag  the nodes within
		a case??

		Got to do something in the following case:

                |
       -------->A----->
      /        /|
      |       / |
      |      /  B
      |      | /|
      |      |/ |
      |      C  |
      |       \ |
      |        \|
      |         D
      \         |
       ---------E

		That is, we must structure C as a conditional header as opposed to
		latch node. This implies that conditional structuring be performed
		first and ALL two nodes be structured as conditional headers. In
		this case, C won't have a follow but that should be ok.

1/8:	Remove the duplication of edges between nodes. That is, if a node
		has been typed as a cBranch but trys to add two edges to
		the same node later during edge building, only one edge is
		added and the node is retyped to be a fall through node.

2/8:	Removed the code that tags the nodes within a case statement.

		It appears as though the second set of set of timestamps
		doesn't not accurately test for case
		statements.

            (1,16)
            / |  \____
           /  |       \
          /   |        |
         /    |      (7,15)
      (2,4) (5,6)     /  \
         \    |      /    \
          \   |  (8,11)  (12,14)
           \  |      \    /
            \  \      \  /
             \  \    (9,13)
              \  \     /
               \  |   /
                \ |  /
                (3,10)

		The node (12,14) in the properly structured case above would
		be detected as lying outside the case by the
		current test. Unless some other algorithm is discovered,
		this means we have to revert to the DFS method
		of determining the structuredness of a case statement. Of
		course, this incurs the function call overhead
		once again. For the purpose of this thesis, this is not a
		problem as this cost will be exactly the same for
		both loop structuring algorithms under comparison.

9/8:	New strategy maybe to combine the structuring of case and
		if-then{-else} constructs into the one routine.  This
		allows us to easily detect cases where a case nested
		within an if-then{-else} shares the same follow as its
		enclosing if-then{-else}. The reverse situation also
		has the same benefit. This also allows us to hopefully
		structure graphs with unstructured case constructs. If
		we are going to attempt this, we must make a decision
		about what to do in the case of overlapping case/loop
		constructs. As first guess, it would be nicer to structure
		the case's instead of the loops in this case as less goto's
		will be generated. To enable this, we are going to have to
		tag the members of a case construct with their respective
		case header node. Also, we are faced with the problem
		of forward edges into a case body and forward egdes out
		of a case body as these will impact upon the numbering
		that could be potentially used to structure case's.

29/8:	Brainwave from Cristina on possible solution for finding the follow
		of an nway header. If we find the immediate postdominators for each
		node, then a suitable follow for an nway header may be its immediate
		post dominator. 

30/8:	The immediate post dominator (IPD) info seems to have big potential.
		At the moment, it seems as though the IPD of a two-way (that doesn't
		have any back edges out from it) will always be a suitable follow
		node. We may only need to use the other method (traverse descendants)
		to determine a more appropriate follow for an nway conditional in
		some cases. I think this will only occur when a case has a forward
		jump out of it.

1/9:	Need to detect conditional jumps out of a loop body as single-clause
		conditionals. 

		It seems as though the IPD is all that is required for conditional-follows
		testing.
6/9:
		Problem graphs when generating code:

	    A          A;         OR       A;
       /|          if (!A)             if (A)
      / |            do {                 goto LC;
     |  B<-             B;             do {
      \ |  \    LC:     C;                B;
       \|   |           D;          LC:   C;
        C  /         }                    D;
        | /        goto LC;            }
        |/
        D

		We would prefer the second one as it really reflects the fact that this is a
		forward jump into a loop, not a loop nested within a conditional with a back-
		ward jump into it. To get the second (nicer) generated code, we need to be able
		to decide which branch of the conditional includes the loop header of the loop
		in which the follow is nested. For a conditional missing a clause, this is
		relatively easy. Otherwise, how do we make the decision? Maybe by just looking
		at the dfsfirst value of the immediate successors of the conditional.

8/9:	Gotta do something about a latching that has two back edges.
